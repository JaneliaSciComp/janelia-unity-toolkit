// A subject (GameObject representing a moving agent) that supports
// kinematic motion, kinematic collision detection, and logging.
// The kinematic motion is provided by the `updater` field, an object
// that must conform to the `Janelia.KinematicSubject.IKinematicUpdater`
// interface.

// An application using a `Janelia.KinematicSubject` can play back the motion
// captured in the log of a previous session.  See `Janelia.PlaybackHandler.cs` in
// org.janelia.collison-handling.

// This class has a post-build step that plugs user interface into the launcher script
// created by the `Janelia.Logger` class from the  `org.janelia.logging` package.
// This user interface shows a list of the log files generated by the application and
// lets the user choose one for playback.

// In addition to logging the motion (rotation and translation) at each frame, this class
// also logs the time spent processing each frame, and also logs some details of all
// the meshes as of the start of the application (if `LOG_ALL_MESHES` is defined).

#define SUPPORT_COMMANDLINE_ARGUMENTS
// #define SUPPORT_KEYBOARD_SHORTCUTS
#define LOG_ALL_MESHES

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
#if UNITY_EDITOR
using UnityEditor.Callbacks;
#endif
using UnityEngine;
using UnityEngine.Rendering;

namespace Janelia
{
    // The `DefaultExecutionOrder` attribute needs to specify a value lower than the default of 0,
    // so `Update()` will execute before the cameras rendered by `Janelia.AdjoningDisplaysCamera`.
    // Otherwise, some of those cameras may be a frame behind, producing vertical "tearing".
    [DefaultExecutionOrder(-100)]
    public class KinematicSubject : MonoBehaviour
    {
        // A class conforming to this interface provides the kinematic motion (translation,
        // rotation) for this subject object.
        public interface IKinematicUpdater
        {
#if UNITY_2021_2_OR_NEWER
            void Start() {}
            void Update() {}

            // These values are relative (displacements).
            Vector3? Translation() => null;
            Vector3? RotationDegrees() => null;
#else
            // With C# 8.0, interfaces can have default implementations.  But through Unity
            // version 2021.2, Unity's C# does not support them.  So classes implementing this interface
            // must implement all the interface methods (i.e., `Start`, `Update`, `Translation`,
            // `Rotation`) even if they do nothing.

            void Start();
            void Update();

            // These values are relative (displacements).
            Vector3? Translation();
            Vector3? RotationDegrees();
#endif
        };

        public bool PlaybackActive
        {
            get => _playbackHandler.PlaybackActive;
        }

        // The object that provides the kinematic motion, to be set by the constructor of
        // the subclass of this class.
        public IKinematicUpdater updater;

        // Parameters of the collision detection supported by this class.
        public float collisionRadius = 1.0f;
        public Vector3? collisionPlaneNormal = null;
        public float limitDistance = 0;
        public Vector3 limitCenter = Vector3.zero;

        // Parameters to control when the log is written.  The goal is to avoid writing
        // either too frequently or not frequently enough.  A heuristic is to write when
        // the subject is "still", that is, when the `IKinematicUpdater` has not given any
        // motion for a small number of frames.
        public bool writeLogWhenStill = true;
        public int stillFrames = 5;

        // That heuristic is further refined so that writing when "still" will not happen
        // before a minimum number of frames have passed since the last writing, and writing
        // will not wait more than a maximum number of frames since the last writing, even
        // if not "still".
        public int minWriteInterval = 100;
        public int maxWriteInterval = 200;

        public bool detectCollisions = true;

        // Look for objects with names that start with "LimitTranslationTo" and limit the
        // translation this subject is inside them (e.g., "LimitTranslationToForward" will
        // not allow motion that is backards relative to its forward axis).
        public bool limitTranslation = true;

        public bool debug = false;

        public void Start()
        {
            if (updater == null)
            {
                Debug.LogError("Janelia.KinematicSubject.updater must be set.");
                Application.Quit();
            }

            foreach (GameObject obj in UnityEngine.Object.FindObjectsOfType<GameObject>())
            {
                if (obj.activeInHierarchy && obj.name.StartsWith("LimitTranslationTo"))
                {
                    _translationLimiters.Add(obj);
                }
            }

            updater.Start();

            // Set up the collision handler to act on this `GameObject`'s transform.
            _collisionHandler = new KinematicCollisionHandler(transform, collisionPlaneNormal, limitDistance, limitCenter, collisionRadius);

            _playbackHandler.ConfigurePlayback();

#if LOG_ALL_MESHES
            LogUtilities.LogAllMeshes();
#endif
        }

        public void Update()
        {
            Transform transf = transform;
            Transformation logTransf = _currentTransformation;
            if (_playbackHandler.Update(ref _currentTransformation, transform))
            {
                // The user may or may not choose to log tracked activity (e.g., from FicTrac) during playback.
                if (!Logger.enable)
                {
                    return;
                }

                // If tracked activity is being logged during playback, then two transforms are needed:
                // the main one gets the playback activity, and this additional one gets the tracked activity.
                if (_playbackLogObject == null)
                {
                    _playbackLogObject = new GameObject();
                    _playbackLogObject.transform.SetPositionAndRotation(transform.position, transform.rotation);
                    _playbackLogTransformation = new Transformation();
                }
                transf = _playbackLogObject.transform;
                logTransf = _playbackLogTransformation;
            }

            _framesBeingStill++;

            _currentTransformation.Clear();
            bool addToLog = false;

            updater.Update();

            Vector3? translation = updater.Translation();
            if (translation != null)
            {
                Vector3 postCollisionTranslation = (Vector3)translation;
                if (detectCollisions)
                {
                    // Let the collision handler correct the translation, with approximated sliding contact,
                    // and apply it to this `GameObject`'s transform.  The corrected translation is returned.
                    postCollisionTranslation = _collisionHandler.CorrectTranslation((Vector3)translation);
                }

                Vector3 actualTranslation = postCollisionTranslation;
                if (limitTranslation)
                {
                    actualTranslation = LimitTranslation(postCollisionTranslation);
                }

                transf.Translate(actualTranslation);

                logTransf.attemptedTranslation = (Vector3)translation;
                logTransf.postCollisionTranslation = postCollisionTranslation;
                logTransf.actualTranslation = actualTranslation;

                if (debug)
                {
                    Debug.Log("frame " + Time.frameCount + ": translation " + translation + " becomes " + actualTranslation);
                }

                addToLog = true;
                _framesBeingStill = 0;
            }

            Vector3? rotation = updater.RotationDegrees();
            if (rotation != null)
            {
                transf.Rotate((Vector3)rotation);
                logTransf.rotationDegs = (Vector3)rotation;

                addToLog = true;
                _framesBeingStill = 0;
            }

            if (addToLog)
            {
                logTransf.worldPosition = transf.position;
                logTransf.worldRotationDegs = transf.eulerAngles;
                Logger.Log(logTransf);
            }

            _framesSinceLogWrite++;
            bool writeLog = false;
            if (writeLogWhenStill)
            {
                if ((_framesBeingStill >= stillFrames) && (_framesSinceLogWrite > minWriteInterval))
                {
                    writeLog = true;
                    if (debug)
                    {
                        Debug.Log("Frame " + Time.frameCount + ", writing log: still for " + _framesBeingStill + " frames, and " +
                            _framesSinceLogWrite + " frames since last write");
                    }
                }
            }
            if (_framesSinceLogWrite >= maxWriteInterval)
            {
                writeLog = true;
                if (debug)
                {
                    Debug.Log("Frame " + Time.frameCount + ", writing log: " + _framesSinceLogWrite + " frames since last write");
                }
            }

            LogUtilities.LogDeltaTime();

            if (writeLog)
            {
                Logger.Write();
                _framesSinceLogWrite = 0;
                _framesBeingStill = 0;
            }
        }

        private Vector3 LimitTranslation(Vector3 translation)
        {
            Vector3 translationLimited = translation;
            foreach (GameObject limiter in _translationLimiters)
            {
                BoxCollider collider = limiter.GetComponent<BoxCollider>() as BoxCollider;
                Vector3 positionColliderSpace = collider.transform.InverseTransformPoint(transform.position);
                Bounds bounds = new Bounds(collider.center, collider.size);
                if (bounds.Contains(positionColliderSpace))
                {
                    if (limiter.name.Contains("Forward"))
                    {
                        Vector3 forward = limiter.transform.forward;
                        Vector3 forwardSubjectSpace = transform.InverseTransformDirection(forward);
                        if (Vector3.Dot(forwardSubjectSpace, translation) < 0)
                        {
                            translationLimited = Vector3.zero;
                            break;
                        }
                    }
                }
            }
            return translationLimited;
        }

#if UNITY_EDITOR
        // The attribute value orders this function after `Logger.OnPostprocessBuildStart` and
        // before `Logger.OnPostprocessBuildFinish`.
        [PostProcessBuildAttribute(2)]
        public static void OnPostprocessBuild(BuildTarget target, string pathToBuiltProject)
        {
            Debug.Log("Janelia.KinematicSubject.OnPostprocessBuild: " + pathToBuiltProject);

            string n = System.Environment.NewLine;
            string radioButtonLabel = "Replay a log of a previous session";
            string radioButtonOtherHTML =
                "          <div>" + n +
                "            <label for='logs'>Choose a log:</label>" + n +
                "            <select name='logs' id='id_selectLogs'></select>" + n +
                "          </div>" + n +
                "          <div>" + n +
                "            <label for='logs'>Log during replay:</label>" + n +
                "            <input type='checkbox' id='id_checkboxLogDuringPlayback' style='width:40px; height:40px;'>" + n +
                "          </div>";
            string scriptBlockWithRadioButtonFunc =
                "    <script language='javascript'>" + n +
                "      var select = document.getElementById('id_selectLogs');" + n +
                "      var fso = new ActiveXObject('Scripting.FileSystemObject');" + n +
                "      var folderPath = LogDir();" + n +
                "      if (fso.FolderExists(folderPath)) {" + n +
                "        var folder = fso.GetFolder(folderPath);" + n +
                "        var files = [];" + n +
                "        for (var en = new Enumerator(folder.Files); !en.atEnd(); en.moveNext()) {" + n +
                "          var s = en.item();" + n +
                "          if (/Log.*json/.test(s))" + n +
                "            files.push(s);" + n +
                "        }" + n +
                "        files.sort();" + n +
                "        for (var i = files.length - 1; i >= 0; i--)" + n +
                "          select.add(new Option(files[i], files[i]));" + n +
                "      }" + n +
                "      if (select.options.length === 0) {" + n +
                "        select.add(new Option('No logs', 0));" + n +
                "        select.disabled = true;" + n +
                "      }" + n +
                "      function actionKinematicSubject()" + n +
                "      {" + n +
                "        var extra = '-playback ' + document.getElementById('id_selectLogs').value;" + n +
                "        var checkboxLogDuringPlayback = document.getElementById('id_checkboxLogDuringPlayback');" + n +
                "        if (checkboxLogDuringPlayback.checked) {" + n +
                "          extra += ' -logDuringPlayback';" + n +
                "        }" + n +
                "        runApp(extra);" + n +
                "      }" + n +
                "    </script>";
            Logger.AddLauncherRadioButtonPlugin(radioButtonLabel, radioButtonOtherHTML, "actionKinematicSubject", scriptBlockWithRadioButtonFunc);
        }
#endif

        private KinematicCollisionHandler _collisionHandler;

        // To make `Janelia.Logger.Log(entry)`'s call to JsonUtility.ToJson() work correctly,
        // the type of `entry` must be marked `[Serlializable]`, but its individual fields need not
        // be marked `[SerializeField]`.  The individual fields must be `public`, though.
        [Serializable]
        internal class Transformation : PlayableLogEntry
        {
            public Vector3 attemptedTranslation;
            public Vector3 postCollisionTranslation;
            public Vector3 actualTranslation;
            public Vector3 rotationDegs;

            public void Clear()
            {
                attemptedTranslation.Set(0, 0, 0);
                postCollisionTranslation.Set(0, 0, 0);
                actualTranslation.Set(0, 0, 0);
                worldPosition.Set(0, 0, 0);
                rotationDegs.Set(0, 0, 0);
                worldRotationDegs.Set(0, 0, 0);
            }

            // Needed only for playback of the log.
            public void Set(Transformation other)
            {
                attemptedTranslation = other.attemptedTranslation;
                postCollisionTranslation = other.postCollisionTranslation;
                actualTranslation = other.actualTranslation;
                worldPosition = other.worldPosition;
                rotationDegs = other.rotationDegs;
                worldRotationDegs = other.worldRotationDegs;
            }
        }

        private Transformation _currentTransformation = new Transformation();
        private Transformation _playbackLogTransformation = null;
        private GameObject _playbackLogObject = null;

        private int _framesSinceLogWrite = 0;
        private int _framesBeingStill = 0;

        private List<GameObject> _translationLimiters = new List<GameObject>();

        private PlaybackHandler<Transformation> _playbackHandler = new PlaybackHandler<Transformation>();
    }
}
